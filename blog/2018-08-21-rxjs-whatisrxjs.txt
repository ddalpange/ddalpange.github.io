0:[[["",{"children":["blog",{"children":[["slug","2018-08-21-rxjs-whatisrxjs","d"],{"children":["__PAGE__?{\"slug\":\"2018-08-21-rxjs-whatisrxjs\"}",{}]}]}]},"$undefined","$undefined",true],"$L1","$L2"]]
3:I{"id":"2070","name":"","chunks":["131:131-718a907043a28311","185:app/layout-e989778009efa586"],"async":false}
4:I{"id":"7131","name":"","chunks":["131:131-718a907043a28311","931:app/page-a8aaecf3dc39acc6"],"async":false}
5:I{"id":"830","name":"","chunks":["272:webpack-a84c954fa8715833","776:0b7c6ed9-60e4a7f8e855a262","474:474-c8c5eb3e5e298e46"],"async":false}
6:I{"id":"2079","name":"","chunks":["272:webpack-a84c954fa8715833","776:0b7c6ed9-60e4a7f8e855a262","474:474-c8c5eb3e5e298e46"],"async":false}
1:[["$","html",null,{"lang":"en","data-theme":"retro","children":[["$","head",null,{"children":[["$","link",null,{"rel":"preconnect","href":"https://cdn.jsdelivr.net"}],["$","link",null,{"rel":"stylesheet","type":"text/css","href":"https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/variable/pretendardvariable.css"}]]}],["$","body",null,{"className":"flex flex-col items-center h-[100svh]","children":[["$","$L3",null,{"src":"https://www.googletagmanager.com/gtag/js?id=G-XR7V7MF96T","strategy":"afterInteractive"}],["$","$L3",null,{"id":"google-analytics","strategy":"afterInteractive","children":"\n          window.dataLayer = window.dataLayer || [];\n          function gtag(){window.dataLayer.push(arguments);}\n          gtag('js', new Date());\n\n          gtag('config', 'G-XR7V7MF96T');\n        "}],["$","div",null,{"className":"w-full max-w-3xl flex-grow","children":[["$","div",null,{"className":"navbar","children":[["$","div",null,{"className":"flex-1","children":["$","$L4",null,{"className":"p-2 hover:underline md:text-2xl font-bold flex gap-4 items-center","href":"/","children":"Yozzing Blog"}]}],["$","div",null,{"className":"flex-none","children":["$","div",null,{"className":"tabs","children":[["$","$L4",null,{"className":"tab","href":"/engineering","children":"Engineering"}],["$","$L4",null,{"className":"tab","href":"/essay","children":"Essay"}],["$","a",null,{"className":"tab","href":"https://github.com/ddalpange","children":["$","div",null,{"className":"avatar","children":["$","div",null,{"className":"w-8 rounded-full","children":["$","img",null,{"alt":"yozzing","src":"/blog/images/profile.jpeg"}]}]}]}]]}]}]]}],["$","div",null,{"className":"p-4 pb-10","children":["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L6",null,{}],"templateStyles":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":"$undefined","asNotFound":false,"childProp":{"current":["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L6",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","asNotFound":false,"childProp":{"current":["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children",["slug","2018-08-21-rxjs-whatisrxjs","d"],"children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L6",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","asNotFound":false,"childProp":{"current":["$L7","$@8"],"segment":"__PAGE__?{\"slug\":\"2018-08-21-rxjs-whatisrxjs\"}"}}],"segment":["slug","2018-08-21-rxjs-whatisrxjs","d"]}}],"segment":"blog"}}]}]]}]]}]]}],"$@9"]
2:[[["$","meta",null,{"charSet":"utf-8"}],["$","title",null,{"children":"RxJS란 무엇인가?"}],["$","meta",null,{"name":"description","content":"<p><code>Observable</code>을 사용하여 비동기 및 이벤트 기반의 프로그램을 작성하기 위한 라이브러리이다. 동기/비동기/이벤트 등 다양한 코드를 동일한 인터페이스로 작성할 수 있다는 점이 매우 인상적이다. <code>RxJS</code>는 <em>Iterator Pattern</em>과 <em>Observer Pattern</em>을 결합하여 이벤트들을 관리하기 위한 효울적인 방법을 제공한다. <code>RxJS</code>의 주요 개념은 다음와 같다.</p>\n"}],null,[[["$","link",null,{"rel":"author","href":"https://github.io/ddalpange"}],["$","meta",null,{"name":"author","content":"ddalpange"}]]],null,null,["$","meta",null,{"name":"keywords","content":"RxJS,Observable,Observer,Subscription,Subject"}],null,null,null,["$","meta",null,{"name":"viewport","content":"width=device-width, initial-scale=1"}],null,null,null,null,null,null,null,null,null,null,[]],[null,null,null,null],null,null,[null,null,null,null,null],null,null,null,null,[null,[["$","link",null,{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"any"}]],[],null]]
a:I{"id":"3969","name":"Disqus","chunks":["308:app/blog/[slug]/page-2754d756216a6ffc"],"async":false}
7:["$","article",null,{"className":"prose max-w-full flex flex-col items-center","children":[["$","span",null,{"className":"mb-2","children":"4년 이상 전"}],["$","h1",null,{"children":"RxJS란 무엇인가?"}],["$","div",null,{"children":["$","div",null,{"className":"prose self-center","children":[["$","p","0",{"children":[["$","code","0",{"children":"Observable"}],"을 사용하여 비동기 및 이벤트 기반의 프로그램을 작성하기 위한 라이브러리이다. 동기/비동기/이벤트 등 다양한 코드를 동일한 인터페이스로 작성할 수 있다는 점이 매우 인상적이다. ",["$","code","2",{"children":"RxJS"}],"는 ",["$","em","4",{"children":"Iterator Pattern"}],"과 ",["$","em","6",{"children":"Observer Pattern"}],"을 결합하여 이벤트들을 관리하기 위한 효울적인 방법을 제공한다. ",["$","code","8",{"children":"RxJS"}],"의 주요 개념은 다음와 같다."]}],"\n",["$","ol","2",{"children":["\n",["$","li","1",{"children":[["$","code","0",{"children":"Observable"}],": 미래에 발생할 이벤트, 값들을 모아놓은 컬렉션이다."]}],"\n",["$","li","3",{"children":[["$","code","0",{"children":"Observer"}],": ",["$","code","2",{"children":"Observable"}],"이 배달한 값을 읽을 수 있도록 하는 콜백들의 컬렉션이다."]}],"\n",["$","li","5",{"children":[["$","code","0",{"children":"Subscription"}],": ",["$","code","2",{"children":"Observable"}],"의 실행을 나타낸다. 기본적으로 ",["$","code","4",{"children":"Observable"}],"의 실행 취소에 적합하다."]}],"\n",["$","li","7",{"children":[["$","code","0",{"children":"Operators"}],": 함수형 프로그램을 제공하기 위한 순수 함수들의 모음이다."]}],"\n",["$","li","9",{"children":[["$","code","0",{"children":"Subject"}],": ",["$","code","2",{"children":"Observer"}],"이자 ",["$","code","4",{"children":"Observable"}],"이다. 다수의 ",["$","code","6",{"children":"Observable"}],"에 브로드캐스팅 할 수 있는 유일한 방법이다."]}],"\n",["$","li","11",{"children":[["$","code","0",{"children":"Scheduler"}],": ",["$","code","2",{"children":"setTimeout"}],", ",["$","code","4",{"children":"requestAnimationFrame"}],"과 같은 비동기 함수의 동시성을 제어할 수 있다."]}],"\n"]}],"\n",["$","h3","4",{"children":"예제"}],"\n",["$","h4","6",{"children":"버튼의 이벤트 리스너"}],"\n",["$","p","8",{"children":"일반적으로 이벤트 리스너를 만드는 코드는 다음과 같다."}],"\n",["$","pre","10",{"children":["$","code",null,{"children":"const button = document.querySelector('button');\nbutton.addEventListener('click', () => console.log('Clicked!'));\n"}]}],"\n",["$","p","12",{"children":["RxJS를 쓴다면 이것을 ",["$","code","1",{"children":"Observable"}],"로 변환 할 수 있다."]}],"\n",["$","pre","14",{"children":["$","code",null,{"children":"const { fromEvent } = rxjs;\n\nconst button = document.querySelector('button');\nfromEvent(button, 'click')\n  .subscribe(() => console.log('Clicked!'));\n"}]}],"\n",["$","h4","16",{"children":"순수성"}],"\n",["$","p","18",{"children":"RxJS는 순수함수를 제공하기 때문에 넘어오는 값은 모두 독립적(불변)이다.\n불변이라는것은 에러가 날 확률이 적어진다는 것과 같다."}],"\n",["$","p","20",{"children":"일반적인 가변 변수를 사용하는 코드이다."}],"\n",["$","pre","22",{"children":["$","code",null,{"children":"var count = 0;\nvar button = document.querySelector('button');\nbutton.addEventListener('click', () => console.log(`Clicked ${++count} times`));\n"}]}],"\n",["$","p","24",{"children":"RxJS를 쓴다면 변수를 불변적으로 관리할 수 있다."}],"\n",["$","pre","26",{"children":["$","code",null,{"children":"const { fromEvent } = rxjs;\nconst { scan } = rxjs.operators;\n\nconst button = document.querySelector('button');\nfromEvent(button, 'click').pipe(\n  scan(count => count + 1, 0)\n)\n.subscribe(count => console.log(`Clicked ${count} times`));\n"}]}],"\n",["$","p","28",{"children":[["$","code","0",{"children":"scan"}],"은 배열의 ",["$","code","2",{"children":"reduce"}],"와 유사하게 동작한다."]}],"\n",["$","h4","30",{"children":"흐름"}],"\n",["$","p","32",{"children":"RxJS는 다양한 오퍼레이터를 통해 이벤트흐름을 제어할 수 있다."}],"\n",["$","p","34",{"children":"그 예로 1초가 지나야 사용자의 클릭을 허용하는 코드가 있다."}],"\n",["$","pre","36",{"children":["$","code",null,{"children":"var count = 0;\nvar rate = 1000;\nvar lastClick = Date.now() - rate;\nvar button = document.querySelector('button');\nbutton.addEventListener('click', () => {\n  if (Date.now() - lastClick >= rate) {\n    console.log(`Clicked ${++count} times`);\n    lastClick = Date.now();\n  }\n});\n"}]}],"\n",["$","p","38",{"children":"이것을 RxJS를 이용한다면 다음의 코드로 바꿀 수 있다."}],"\n",["$","pre","40",{"children":["$","code",null,{"children":"const { fromEvent } = rxjs;\nconst { throttleTime, scan } = rxjs.operators;\n\nconst button = document.querySelector('button');\nfromEvent(button, 'click').pipe(\n  throttleTime(1000),\n  scan(count => count + 1, 0)\n)\n.subscribe(count => console.log(`Clicked ${count} times`));\n"}]}],"\n",["$","p","42",{"children":[["$","code","0",{"children":"throttleTime"}]," 외에도 ",["$","code","2",{"children":"delay"}],", ",["$","code","4",{"children":"debounceTime"}],", ",["$","code","6",{"children":"take"}],", ",["$","code","8",{"children":"takeUntil"}],", ",["$","code","10",{"children":"distinct"}],", ",["$","code","12",{"children":"distinctUntilChanged"}]," 등 엄청나게 많은 오퍼레이터를 제공한다"]}],"\n",["$","h4","44",{"children":"유연한 값"}],"\n",["$","p","46",{"children":"구독이 일어나기 전 오퍼레이터들을 이용하여 값들을 미리 변환시킬 수 있다."}],"\n",["$","p","48",{"children":"클릭할 때마다 마우스의 X Position을 더해주는 코드는 아래와 같다."}],"\n",["$","pre","50",{"children":["$","code",null,{"children":"let count = 0;\nconst rate = 1000;\nlet lastClick = Date.now() - rate;\nconst button = document.querySelector('button');\nbutton.addEventListener('click', (event) => {\n  if (Date.now() - lastClick >= rate) {\n    count += event.clientX;\n    console.log(count)\n    lastClick = Date.now();\n  }\n});\n"}]}],"\n",["$","p","52",{"children":"이것을 RxJS로 쓴다면 아래와 같다."}],"\n",["$","pre","54",{"children":["$","code",null,{"children":"const { fromEvent } = rxjs;\nconst { throttleTime, map, scan } = rxjs.operators;\n\nconst button = document.querySelector('button');\nfromEvent(button, 'click').pipe(\n  throttleTime(1000),\n  map(event => event.clientX),\n  scan((count, clientX) => count + clientX, 0)\n)\n.subscribe(count => console.log(count));\n"}]}],"\n",["$","p","56",{"children":["이 밖에도 ",["$","code","1",{"children":"pluck"}],", ",["$","code","3",{"children":"pairwise"}],", ",["$","code","5",{"children":"sample"}],"과 같은 다양한 오퍼레이터를 지원한다."]}],"\n"]}]}],["$","$La",null,{"post":{"title":"RxJS란 무엇인가?","date":"2018-08-21T14:51:12.000Z","thumbnail":"https://cdn-images-1.medium.com/fit/t/1600/480/1*gD37OB2-PtMqZdk3X1YnEQ.png","tags":["RxJS","Observable","Observer","Subscription","Subject"],"categories":["RxJS"],"content":"\n`Observable`을 사용하여 비동기 및 이벤트 기반의 프로그램을 작성하기 위한 라이브러리이다. 동기/비동기/이벤트 등 다양한 코드를 동일한 인터페이스로 작성할 수 있다는 점이 매우 인상적이다. `RxJS`는 *Iterator Pattern*과 *Observer Pattern*을 결합하여 이벤트들을 관리하기 위한 효울적인 방법을 제공한다. `RxJS`의 주요 개념은 다음와 같다.\n\n<!-- more -->\n\n1. ``Observable``: 미래에 발생할 이벤트, 값들을 모아놓은 컬렉션이다.\n2. ``Observer``: `Observable`이 배달한 값을 읽을 수 있도록 하는 콜백들의 컬렉션이다.\n3. `Subscription`: `Observable`의 실행을 나타낸다. 기본적으로 `Observable`의 실행 취소에 적합하다.\n4. `Operators`: 함수형 프로그램을 제공하기 위한 순수 함수들의 모음이다.\n5. `Subject`: `Observer`이자 `Observable`이다. 다수의 `Observable`에 브로드캐스팅 할 수 있는 유일한 방법이다.\n6. `Scheduler`: `setTimeout`, `requestAnimationFrame`과 같은 비동기 함수의 동시성을 제어할 수 있다.\n\n### 예제\n\n#### 버튼의 이벤트 리스너\n\n일반적으로 이벤트 리스너를 만드는 코드는 다음과 같다.\n\n```javascript\nconst button = document.querySelector('button');\nbutton.addEventListener('click', () => console.log('Clicked!'));\n```\n\nRxJS를 쓴다면 이것을 `Observable`로 변환 할 수 있다.\n\n```javascript\nconst { fromEvent } = rxjs;\n\nconst button = document.querySelector('button');\nfromEvent(button, 'click')\n  .subscribe(() => console.log('Clicked!'));\n```\n\n\n#### 순수성\n\nRxJS는 순수함수를 제공하기 때문에 넘어오는 값은 모두 독립적(불변)이다.\n불변이라는것은 에러가 날 확률이 적어진다는 것과 같다.\n \n\n일반적인 가변 변수를 사용하는 코드이다.\n\n```javascript\nvar count = 0;\nvar button = document.querySelector('button');\nbutton.addEventListener('click', () => console.log(`Clicked ${++count} times`));\n```\n\nRxJS를 쓴다면 변수를 불변적으로 관리할 수 있다.\n\n```javascript\nconst { fromEvent } = rxjs;\nconst { scan } = rxjs.operators;\n\nconst button = document.querySelector('button');\nfromEvent(button, 'click').pipe(\n  scan(count => count + 1, 0)\n)\n.subscribe(count => console.log(`Clicked ${count} times`));\n```\n\n`scan`은 배열의 `reduce`와 유사하게 동작한다.\n\n\n#### 흐름\n\nRxJS는 다양한 오퍼레이터를 통해 이벤트흐름을 제어할 수 있다.\n\n그 예로 1초가 지나야 사용자의 클릭을 허용하는 코드가 있다.\n\n```javascript\nvar count = 0;\nvar rate = 1000;\nvar lastClick = Date.now() - rate;\nvar button = document.querySelector('button');\nbutton.addEventListener('click', () => {\n  if (Date.now() - lastClick >= rate) {\n    console.log(`Clicked ${++count} times`);\n    lastClick = Date.now();\n  }\n});\n```\n\n이것을 RxJS를 이용한다면 다음의 코드로 바꿀 수 있다.\n\n```javascript\nconst { fromEvent } = rxjs;\nconst { throttleTime, scan } = rxjs.operators;\n\nconst button = document.querySelector('button');\nfromEvent(button, 'click').pipe(\n  throttleTime(1000),\n  scan(count => count + 1, 0)\n)\n.subscribe(count => console.log(`Clicked ${count} times`));\n```\n\n`throttleTime` 외에도 `delay`, `debounceTime`, `take`, `takeUntil`, `distinct`, `distinctUntilChanged` 등 엄청나게 많은 오퍼레이터를 제공한다\n\n#### 유연한 값\n\n구독이 일어나기 전 오퍼레이터들을 이용하여 값들을 미리 변환시킬 수 있다.\n\n클릭할 때마다 마우스의 X Position을 더해주는 코드는 아래와 같다.\n\n```javascript\nlet count = 0;\nconst rate = 1000;\nlet lastClick = Date.now() - rate;\nconst button = document.querySelector('button');\nbutton.addEventListener('click', (event) => {\n  if (Date.now() - lastClick >= rate) {\n    count += event.clientX;\n    console.log(count)\n    lastClick = Date.now();\n  }\n});\n```\n\n이것을 RxJS로 쓴다면 아래와 같다.\n\n```javascript\nconst { fromEvent } = rxjs;\nconst { throttleTime, map, scan } = rxjs.operators;\n\nconst button = document.querySelector('button');\nfromEvent(button, 'click').pipe(\n  throttleTime(1000),\n  map(event => event.clientX),\n  scan((count, clientX) => count + clientX, 0)\n)\n.subscribe(count => console.log(count));\n```\n\n이 밖에도 `pluck`, `pairwise`, `sample`과 같은 다양한 오퍼레이터를 지원한다.\n<!--stackedit_data:\neyJoaXN0b3J5IjpbMTYxMjQzMzkwNywtMjA1MDg1MzQ4MiwtMT\nU0MTI3NTgwMF19\n-->","contentHtml":"<p><code>Observable</code>을 사용하여 비동기 및 이벤트 기반의 프로그램을 작성하기 위한 라이브러리이다. 동기/비동기/이벤트 등 다양한 코드를 동일한 인터페이스로 작성할 수 있다는 점이 매우 인상적이다. <code>RxJS</code>는 <em>Iterator Pattern</em>과 <em>Observer Pattern</em>을 결합하여 이벤트들을 관리하기 위한 효울적인 방법을 제공한다. <code>RxJS</code>의 주요 개념은 다음와 같다.</p>\n<ol>\n<li><code>Observable</code>: 미래에 발생할 이벤트, 값들을 모아놓은 컬렉션이다.</li>\n<li><code>Observer</code>: <code>Observable</code>이 배달한 값을 읽을 수 있도록 하는 콜백들의 컬렉션이다.</li>\n<li><code>Subscription</code>: <code>Observable</code>의 실행을 나타낸다. 기본적으로 <code>Observable</code>의 실행 취소에 적합하다.</li>\n<li><code>Operators</code>: 함수형 프로그램을 제공하기 위한 순수 함수들의 모음이다.</li>\n<li><code>Subject</code>: <code>Observer</code>이자 <code>Observable</code>이다. 다수의 <code>Observable</code>에 브로드캐스팅 할 수 있는 유일한 방법이다.</li>\n<li><code>Scheduler</code>: <code>setTimeout</code>, <code>requestAnimationFrame</code>과 같은 비동기 함수의 동시성을 제어할 수 있다.</li>\n</ol>\n<h3>예제</h3>\n<h4>버튼의 이벤트 리스너</h4>\n<p>일반적으로 이벤트 리스너를 만드는 코드는 다음과 같다.</p>\n<pre><code>const button = document.querySelector('button');\nbutton.addEventListener('click', () => console.log('Clicked!'));\n</code></pre>\n<p>RxJS를 쓴다면 이것을 <code>Observable</code>로 변환 할 수 있다.</p>\n<pre><code>const { fromEvent } = rxjs;\n\nconst button = document.querySelector('button');\nfromEvent(button, 'click')\n  .subscribe(() => console.log('Clicked!'));\n</code></pre>\n<h4>순수성</h4>\n<p>RxJS는 순수함수를 제공하기 때문에 넘어오는 값은 모두 독립적(불변)이다.\n불변이라는것은 에러가 날 확률이 적어진다는 것과 같다.</p>\n<p>일반적인 가변 변수를 사용하는 코드이다.</p>\n<pre><code>var count = 0;\nvar button = document.querySelector('button');\nbutton.addEventListener('click', () => console.log(`Clicked ${++count} times`));\n</code></pre>\n<p>RxJS를 쓴다면 변수를 불변적으로 관리할 수 있다.</p>\n<pre><code>const { fromEvent } = rxjs;\nconst { scan } = rxjs.operators;\n\nconst button = document.querySelector('button');\nfromEvent(button, 'click').pipe(\n  scan(count => count + 1, 0)\n)\n.subscribe(count => console.log(`Clicked ${count} times`));\n</code></pre>\n<p><code>scan</code>은 배열의 <code>reduce</code>와 유사하게 동작한다.</p>\n<h4>흐름</h4>\n<p>RxJS는 다양한 오퍼레이터를 통해 이벤트흐름을 제어할 수 있다.</p>\n<p>그 예로 1초가 지나야 사용자의 클릭을 허용하는 코드가 있다.</p>\n<pre><code>var count = 0;\nvar rate = 1000;\nvar lastClick = Date.now() - rate;\nvar button = document.querySelector('button');\nbutton.addEventListener('click', () => {\n  if (Date.now() - lastClick >= rate) {\n    console.log(`Clicked ${++count} times`);\n    lastClick = Date.now();\n  }\n});\n</code></pre>\n<p>이것을 RxJS를 이용한다면 다음의 코드로 바꿀 수 있다.</p>\n<pre><code>const { fromEvent } = rxjs;\nconst { throttleTime, scan } = rxjs.operators;\n\nconst button = document.querySelector('button');\nfromEvent(button, 'click').pipe(\n  throttleTime(1000),\n  scan(count => count + 1, 0)\n)\n.subscribe(count => console.log(`Clicked ${count} times`));\n</code></pre>\n<p><code>throttleTime</code> 외에도 <code>delay</code>, <code>debounceTime</code>, <code>take</code>, <code>takeUntil</code>, <code>distinct</code>, <code>distinctUntilChanged</code> 등 엄청나게 많은 오퍼레이터를 제공한다</p>\n<h4>유연한 값</h4>\n<p>구독이 일어나기 전 오퍼레이터들을 이용하여 값들을 미리 변환시킬 수 있다.</p>\n<p>클릭할 때마다 마우스의 X Position을 더해주는 코드는 아래와 같다.</p>\n<pre><code>let count = 0;\nconst rate = 1000;\nlet lastClick = Date.now() - rate;\nconst button = document.querySelector('button');\nbutton.addEventListener('click', (event) => {\n  if (Date.now() - lastClick >= rate) {\n    count += event.clientX;\n    console.log(count)\n    lastClick = Date.now();\n  }\n});\n</code></pre>\n<p>이것을 RxJS로 쓴다면 아래와 같다.</p>\n<pre><code>const { fromEvent } = rxjs;\nconst { throttleTime, map, scan } = rxjs.operators;\n\nconst button = document.querySelector('button');\nfromEvent(button, 'click').pipe(\n  throttleTime(1000),\n  map(event => event.clientX),\n  scan((count, clientX) => count + clientX, 0)\n)\n.subscribe(count => console.log(count));\n</code></pre>\n<p>이 밖에도 <code>pluck</code>, <code>pairwise</code>, <code>sample</code>과 같은 다양한 오퍼레이터를 지원한다.</p>\n","summary":"<p><code>Observable</code>을 사용하여 비동기 및 이벤트 기반의 프로그램을 작성하기 위한 라이브러리이다. 동기/비동기/이벤트 등 다양한 코드를 동일한 인터페이스로 작성할 수 있다는 점이 매우 인상적이다. <code>RxJS</code>는 <em>Iterator Pattern</em>과 <em>Observer Pattern</em>을 결합하여 이벤트들을 관리하기 위한 효울적인 방법을 제공한다. <code>RxJS</code>의 주요 개념은 다음와 같다.</p>\n","slug":"2018-08-21-rxjs-whatisrxjs","link":"/blog/2018-08-21-rxjs-whatisrxjs"}}]]}]
8:[null,null,[]]
9:[null,null,[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/3127ef311b686118.css","precedence":"next.js"}]]]
