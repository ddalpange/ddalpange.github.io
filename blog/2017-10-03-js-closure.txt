1:HL["/_next/static/css/3127ef311b686118.css",{"as":"style"}]
0:[[["",{"children":["blog",{"children":[["slug","2017-10-03-js-closure","d"],{"children":["__PAGE__?{\"slug\":\"2017-10-03-js-closure\"}",{}]}]}]},"$undefined","$undefined",true],"$L2",[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/3127ef311b686118.css","precedence":"next"}]],["$L3",null]]]]
4:I{"id":"8717","chunks":["146:static/chunks/146-0b9edffcecace5b8.js","185:static/chunks/app/layout-588365b8ca87dbfe.js"],"name":"","async":false}
5:I{"id":"3146","chunks":["146:static/chunks/146-0b9edffcecace5b8.js","179:static/chunks/app/essay/page-692c51b8a8fdf410.js"],"name":"","async":false}
6:I{"id":"9082","chunks":["272:static/chunks/webpack-a84c954fa8715833.js","763:static/chunks/3545d7d3-1319cab7d7f01495.js","895:static/chunks/895-890d488364659f80.js"],"name":"","async":false}
7:I{"id":"4127","chunks":["272:static/chunks/webpack-a84c954fa8715833.js","763:static/chunks/3545d7d3-1319cab7d7f01495.js","895:static/chunks/895-890d488364659f80.js"],"name":"","async":false}
2:[["$","html",null,{"lang":"en","data-theme":"retro","children":[["$","head",null,{"children":[["$","link",null,{"rel":"preconnect","href":"https://cdn.jsdelivr.net"}],["$","link",null,{"rel":"stylesheet","type":"text/css","href":"https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/variable/pretendardvariable.css"}]]}],["$","body",null,{"className":"flex flex-col items-center h-[100svh]","children":[["$","$L4",null,{"src":"https://www.googletagmanager.com/gtag/js?id=G-XR7V7MF96T","strategy":"afterInteractive"}],["$","$L4",null,{"id":"google-analytics","strategy":"afterInteractive","children":"\n          window.dataLayer = window.dataLayer || [];\n          function gtag(){window.dataLayer.push(arguments);}\n          gtag('js', new Date());\n\n          gtag('config', 'G-XR7V7MF96T');\n        "}],["$","div",null,{"className":"w-full max-w-3xl flex-grow","children":[["$","div",null,{"className":"navbar","children":[["$","div",null,{"className":"flex-1","children":["$","$L5",null,{"className":"p-2 hover:underline md:text-2xl font-bold flex gap-4 items-center","href":"/","children":"Yozzing Blog"}]}],["$","div",null,{"className":"flex-none","children":["$","div",null,{"className":"tabs","children":[["$","$L5",null,{"className":"tab","href":"/engineering","children":"Engineering"}],["$","$L5",null,{"className":"tab","href":"/essay","children":"Essay"}],["$","a",null,{"className":"tab","href":"https://github.com/ddalpange","children":["$","div",null,{"className":"avatar","children":["$","div",null,{"className":"w-8 rounded-full","children":["$","img",null,{"alt":"yozzing","src":"/blog/images/profile.jpeg"}]}]}]}]]}]}]]}],["$","div",null,{"className":"p-4 pb-10","children":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","asNotFound":"$undefined","childProp":{"current":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","asNotFound":"$undefined","childProp":{"current":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children",["slug","2017-10-03-js-closure","d"],"children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","asNotFound":"$undefined","childProp":{"current":["$L8",null],"segment":"__PAGE__?{\"slug\":\"2017-10-03-js-closure\"}"},"styles":[]}],"segment":["slug","2017-10-03-js-closure","d"]},"styles":[]}],"segment":"blog"},"styles":[]}]}]]}]]}]]}],null]
3:[[["$","meta",null,{"charSet":"utf-8"}],["$","title",null,{"children":"자바스크립트 클로져"}],["$","meta",null,{"name":"description","content":"<p>자바스크립트의 주요 개념중 하나인 클로져에 대해 자세히 알아보자.</p>\n"}],null,[[["$","link",null,{"rel":"author","href":"https://github.io/ddalpange"}],["$","meta",null,{"name":"author","content":"ddalpange"}]]],null,null,["$","meta",null,{"name":"keywords","content":"Javascript,Closure"}],null,null,null,["$","meta",null,{"name":"viewport","content":"width=device-width, initial-scale=1"}],null,null,null,null,null,null,null,null,null,null,[]],[null,null,null,null],null,null,[null,null,null,null,null],null,null,null,null,null]
9:I{"id":"9432","chunks":["308:static/chunks/app/blog/[slug]/page-c76664ffa773d92a.js"],"name":"Disqus","async":false}
8:["$","article",null,{"className":"prose max-w-full flex flex-col items-center","children":[["$","span",null,{"className":"mb-2","children":"5년 이상 전"}],["$","h1",null,{"children":"자바스크립트 클로져"}],["$","div",null,{"children":["$","div",null,{"className":"prose self-center","children":[["$","p","0",{"children":"자바스크립트의 주요 개념중 하나인 클로져에 대해 자세히 알아보자."}],"\n",["$","p","2",{"children":["$","strong",null,{"children":"클로져"}]}],"\n",["$","p","4",{"children":["클로져는 독립적인 (자유) 변수 (지역적으로 사용되지만, 둘러싼 범위 안에서 정의된 변수)를 참조하는 함수들이다.\n다른 말로 해석하면,\n이 함수들은 그들이 생성된 환경을 ",["$","strong","1",{"children":"기억"}],"한다."]}],"\n",["$","p","6",{"children":["$","strong",null,{"children":"한가지 의문"}]}],"\n",["$","p","8",{"children":"클로져는 지역적으로 선언되었지만, 해당 함수가 선언된 블럭 안에 있는 독립된 변수들을 참조할 수 있는 함수라고 하였다.\n위 문장에서만 보면 자바스크립트의 모든 함수는 해당 블럭의 변수를 참조할 수 있음으로 자바스크립트의 모든 함수는 클로져라 할 수 있다.\n하지만 과연 자바스크립트의 모든 함수는 클로져일까 ??"}],"\n",["$","pre","10",{"children":["$","code",null,{"children":"function init() {\n  var name = \"Mozilla\";\n  \n  function displayName() { // displayName()은 내부 함수인, 클로져다\n    alert(name); // 부모 함수에서 선언된 변수를 사용한다\n  }\n\n  displayName();\n}\n\ninit();\n"}]}],"\n",["$","p","12",{"children":[["$","code","0",{"children":"displayName"}],"은 자신이 선언된 환경을 기억하였다. 그렇다면 ",["$","code","2",{"children":"displayName"}],"은 클로져라고 부를 수 있는가 ?"]}],"\n",["$","pre","14",{"children":["$","code",null,{"children":"function makeFunc() {\n  var name = \"Mozilla\";\n\n  function displayName() {\n    alert(name);\n  }\n\n  return displayName;\n}\n\nvar myFunc = makeFunc();\nmyFunc();\n"}]}],"\n",["$","p","16",{"children":[["$","code","0",{"children":"myFunc"}]," 를 실행했을 때 ",["$","code","2",{"children":"makeFunc"}],"에 대한 참조가 없음에도 불구하고 ",["$","code","4",{"children":"makeFunc"}],"의 지역변수인 ",["$","code","6",{"children":"name"}]," 변수에 정상적으로 접근할 수 있다. 이상하지 않은가?"]}],"\n",["$","p","18",{"children":[["$","code","0",{"children":"displayName"}],"은 자신이 선언된 스코프에서 벗어나 global 환경에서 초기화되었다.\n스코프 탐색은 실행스택과는 관련이 없는 ",["$","code","2",{"children":"makeFunc"}],"를 거쳐갔으며 ",["$","code","4",{"children":"displayName"}],"의 외부 스코프는 global이 아닌 ",["$","code","6",{"children":"makeFunc"}],"의 스코프이다."]}],"\n",["$","p","20",{"children":[["$","code","0",{"children":"myFunc"}],"가 글로벌 환경에서 초기화 되더라도 리턴된 ",["$","code","2",{"children":"dispalyName"}],"의 스코프체인은 ",["$","code","4",{"children":"displayName"}]," -> ",["$","code","6",{"children":"makeFunc"}]," -> ",["$","code","8",{"children":"global"}]," 순으로 형성된다."]}],"\n",["$","p","22",{"children":["즉 초기화되는 위치와 관계없이 해당 함수가 ",["$","strong","1",{"children":"선언"}],"된 곳에서 스코프를 형성한다는 뜻이다."]}],"\n",["$","p","24",{"children":[["$","code","0",{"children":"myFunc"}],"에 null을 할당하지 않으면 가비지콜렉터가 ",["$","code","2",{"children":"makeFunc"}],"의 메모리를 해제하지 않기 때문에 클로져를 사용한다면 별도로 꼭 null을 할당해줘야한다."]}],"\n",["$","pre","26",{"children":["$","code",null,{"children":"function count() {\n    var i;\n    for (i = 1; i < 10; i ++) {\n        setTimeout(function timer() {\n            console.log(i);\n        }, i*100);\n    }\n}\ncount();\n"}]}],"\n",["$","p","28",{"children":["1 ~ 10까지 1씩 증가하여 출력하는 코드를 원했지만 결과는 기대와 달리 10이 9번 출력된다.\n0.1초동안 i는 10이 되었기 때문이며 클로져함수 timer에서 외부 스코프인 ",["$","code","1",{"children":"count"}],"의 변수인 ",["$","code","3",{"children":"i"}],"에 직접 접근하여 출력하였기 때문이다.\n해당 코드를 원하는 결과값으로 바꾸기 위해 어떻게 해야할까 ?"]}],"\n",["$","p","30",{"children":["$","strong",null,{"children":"내부 스코프를 하나 더 추가하는 방식."}]}],"\n",["$","pre","32",{"children":["$","code",null,{"children":"function count() {\n    var i;\n    for (i = 1; i < 10; i += 1) {\n        (function(countingNumber) {\n            setTimeout(function timer() {\n                console.log(countingNumber);\n            }, i * 100);\n        })(i);\n    }\n}\ncount();\n"}]}],"\n",["$","p","34",{"children":["$","strong",null,{"children":"블록 스코프를 이용하는 방식"}]}],"\n",["$","pre","36",{"children":["$","code",null,{"children":"function count() {\n    'use strict';\n    for (let i = 1; i < 10; i += 1) {\n        setTimeout(function timer() {\n            console.log(i);\n        }, i * 100);\n    }\n}\ncount();\n"}]}],"\n",["$","p","38",{"children":[["$","strong","0",{"children":"느낀 점"}],"\n클로져는 재미있는 개념이다. 클로져란 개념을 이해하기 위해서 11개 정도의 글을 정독하였는데, 사람마다 이해하는 클로져의 개념이 다 똑같은것 같지는 않다.\n최대한 다양한 관점에서 클로져를 바라보고 글을 쓸려고 노력하였는데 결국 나랑 비슷한 사람의 글을 거의 베끼다시피 한것 같다.\n언제나 느끼지만 글쓰기는 참 어렵다."]}],"\n",["$","p","40",{"children":["$","strong",null,{"children":"참고"}]}],"\n",["$","ol","42",{"children":["\n",["$","li","1",{"children":"http://blog.javarouka.me/2012/01/javascripts-closure.html"}],"\n",["$","li","3",{"children":"http://meetup.toast.com/posts/86"}],"\n",["$","li","5",{"children":"http://unikys.tistory.com/309"}],"\n"]}],"\n"]}]}],["$","$L9",null,{"post":{"title":"자바스크립트 클로져","date":"2017-10-03T22:44:53.000Z","thumbnail":null,"categories":["Javascript"],"tags":["Javascript","Closure"],"toc":true,"content":"\n자바스크립트의 주요 개념중 하나인 클로져에 대해 자세히 알아보자.\n\n<!-- more -->\n\n**클로져**\n\n클로져는 독립적인 (자유) 변수 (지역적으로 사용되지만, 둘러싼 범위 안에서 정의된 변수)를 참조하는 함수들이다. \n다른 말로 해석하면, \n이 함수들은 그들이 생성된 환경을 **기억**한다.\n\n**한가지 의문**\n\n클로져는 지역적으로 선언되었지만, 해당 함수가 선언된 블럭 안에 있는 독립된 변수들을 참조할 수 있는 함수라고 하였다. \n위 문장에서만 보면 자바스크립트의 모든 함수는 해당 블럭의 변수를 참조할 수 있음으로 자바스크립트의 모든 함수는 클로져라 할 수 있다. \n하지만 과연 자바스크립트의 모든 함수는 클로져일까 ??\n\n\n```javascript\nfunction init() {\n  var name = \"Mozilla\";\n  \n  function displayName() { // displayName()은 내부 함수인, 클로져다\n    alert(name); // 부모 함수에서 선언된 변수를 사용한다\n  }\n\n  displayName();\n}\n\ninit();\n```\n`displayName`은 자신이 선언된 환경을 기억하였다. 그렇다면 `displayName`은 클로져라고 부를 수 있는가 ?\n\n\n```javascript\nfunction makeFunc() {\n  var name = \"Mozilla\";\n\n  function displayName() {\n    alert(name);\n  }\n\n  return displayName;\n}\n\nvar myFunc = makeFunc();\nmyFunc();\n```\n`myFunc` 를 실행했을 때 `makeFunc`에 대한 참조가 없음에도 불구하고 `makeFunc`의 지역변수인 `name` 변수에 정상적으로 접근할 수 있다. 이상하지 않은가?\n\n`displayName`은 자신이 선언된 스코프에서 벗어나 global 환경에서 초기화되었다.\n스코프 탐색은 실행스택과는 관련이 없는 `makeFunc`를 거쳐갔으며 `displayName`의 외부 스코프는 global이 아닌 `makeFunc`의 스코프이다. \n\n`myFunc`가 글로벌 환경에서 초기화 되더라도 리턴된 `dispalyName`의 스코프체인은 `displayName` -> `makeFunc` -> `global` 순으로 형성된다. \n\n즉 초기화되는 위치와 관계없이 해당 함수가 **선언**된 곳에서 스코프를 형성한다는 뜻이다.\n\n`myFunc`에 null을 할당하지 않으면 가비지콜렉터가 `makeFunc`의 메모리를 해제하지 않기 때문에 클로져를 사용한다면 별도로 꼭 null을 할당해줘야한다.\n\n```javascript\nfunction count() {\n    var i;\n    for (i = 1; i < 10; i ++) {\n        setTimeout(function timer() {\n            console.log(i);\n        }, i*100);\n    }\n}\ncount();\n```\n\n1 ~ 10까지 1씩 증가하여 출력하는 코드를 원했지만 결과는 기대와 달리 10이 9번 출력된다. \n0.1초동안 i는 10이 되었기 때문이며 클로져함수 timer에서 외부 스코프인 `count`의 변수인 `i`에 직접 접근하여 출력하였기 때문이다. \n해당 코드를 원하는 결과값으로 바꾸기 위해 어떻게 해야할까 ?\n\n**내부 스코프를 하나 더 추가하는 방식.**\n\n```javascript\nfunction count() {\n    var i;\n    for (i = 1; i < 10; i += 1) {\n        (function(countingNumber) {\n            setTimeout(function timer() {\n                console.log(countingNumber);\n            }, i * 100);\n        })(i);\n    }\n}\ncount();\n```\n\n**블록 스코프를 이용하는 방식**\n\n```javascript\nfunction count() {\n    'use strict';\n    for (let i = 1; i < 10; i += 1) {\n        setTimeout(function timer() {\n            console.log(i);\n        }, i * 100);\n    }\n}\ncount();\n```\n\n**느낀 점**\n클로져는 재미있는 개념이다. 클로져란 개념을 이해하기 위해서 11개 정도의 글을 정독하였는데, 사람마다 이해하는 클로져의 개념이 다 똑같은것 같지는 않다.\n최대한 다양한 관점에서 클로져를 바라보고 글을 쓸려고 노력하였는데 결국 나랑 비슷한 사람의 글을 거의 베끼다시피 한것 같다.\n언제나 느끼지만 글쓰기는 참 어렵다.\n\n\n**참고**\n\n1. http://blog.javarouka.me/2012/01/javascripts-closure.html\n2. http://meetup.toast.com/posts/86\n3. http://unikys.tistory.com/309\n<!--stackedit_data:\neyJoaXN0b3J5IjpbMTg1Njg2ODQ5Nl19\n-->","contentHtml":"<p>자바스크립트의 주요 개념중 하나인 클로져에 대해 자세히 알아보자.</p>\n<p><strong>클로져</strong></p>\n<p>클로져는 독립적인 (자유) 변수 (지역적으로 사용되지만, 둘러싼 범위 안에서 정의된 변수)를 참조하는 함수들이다.\n다른 말로 해석하면,\n이 함수들은 그들이 생성된 환경을 <strong>기억</strong>한다.</p>\n<p><strong>한가지 의문</strong></p>\n<p>클로져는 지역적으로 선언되었지만, 해당 함수가 선언된 블럭 안에 있는 독립된 변수들을 참조할 수 있는 함수라고 하였다.\n위 문장에서만 보면 자바스크립트의 모든 함수는 해당 블럭의 변수를 참조할 수 있음으로 자바스크립트의 모든 함수는 클로져라 할 수 있다.\n하지만 과연 자바스크립트의 모든 함수는 클로져일까 ??</p>\n<pre><code>function init() {\n  var name = \"Mozilla\";\n  \n  function displayName() { // displayName()은 내부 함수인, 클로져다\n    alert(name); // 부모 함수에서 선언된 변수를 사용한다\n  }\n\n  displayName();\n}\n\ninit();\n</code></pre>\n<p><code>displayName</code>은 자신이 선언된 환경을 기억하였다. 그렇다면 <code>displayName</code>은 클로져라고 부를 수 있는가 ?</p>\n<pre><code>function makeFunc() {\n  var name = \"Mozilla\";\n\n  function displayName() {\n    alert(name);\n  }\n\n  return displayName;\n}\n\nvar myFunc = makeFunc();\nmyFunc();\n</code></pre>\n<p><code>myFunc</code> 를 실행했을 때 <code>makeFunc</code>에 대한 참조가 없음에도 불구하고 <code>makeFunc</code>의 지역변수인 <code>name</code> 변수에 정상적으로 접근할 수 있다. 이상하지 않은가?</p>\n<p><code>displayName</code>은 자신이 선언된 스코프에서 벗어나 global 환경에서 초기화되었다.\n스코프 탐색은 실행스택과는 관련이 없는 <code>makeFunc</code>를 거쳐갔으며 <code>displayName</code>의 외부 스코프는 global이 아닌 <code>makeFunc</code>의 스코프이다.</p>\n<p><code>myFunc</code>가 글로벌 환경에서 초기화 되더라도 리턴된 <code>dispalyName</code>의 스코프체인은 <code>displayName</code> -> <code>makeFunc</code> -> <code>global</code> 순으로 형성된다.</p>\n<p>즉 초기화되는 위치와 관계없이 해당 함수가 <strong>선언</strong>된 곳에서 스코프를 형성한다는 뜻이다.</p>\n<p><code>myFunc</code>에 null을 할당하지 않으면 가비지콜렉터가 <code>makeFunc</code>의 메모리를 해제하지 않기 때문에 클로져를 사용한다면 별도로 꼭 null을 할당해줘야한다.</p>\n<pre><code>function count() {\n    var i;\n    for (i = 1; i &#x3C; 10; i ++) {\n        setTimeout(function timer() {\n            console.log(i);\n        }, i*100);\n    }\n}\ncount();\n</code></pre>\n<p>1 ~ 10까지 1씩 증가하여 출력하는 코드를 원했지만 결과는 기대와 달리 10이 9번 출력된다.\n0.1초동안 i는 10이 되었기 때문이며 클로져함수 timer에서 외부 스코프인 <code>count</code>의 변수인 <code>i</code>에 직접 접근하여 출력하였기 때문이다.\n해당 코드를 원하는 결과값으로 바꾸기 위해 어떻게 해야할까 ?</p>\n<p><strong>내부 스코프를 하나 더 추가하는 방식.</strong></p>\n<pre><code>function count() {\n    var i;\n    for (i = 1; i &#x3C; 10; i += 1) {\n        (function(countingNumber) {\n            setTimeout(function timer() {\n                console.log(countingNumber);\n            }, i * 100);\n        })(i);\n    }\n}\ncount();\n</code></pre>\n<p><strong>블록 스코프를 이용하는 방식</strong></p>\n<pre><code>function count() {\n    'use strict';\n    for (let i = 1; i &#x3C; 10; i += 1) {\n        setTimeout(function timer() {\n            console.log(i);\n        }, i * 100);\n    }\n}\ncount();\n</code></pre>\n<p><strong>느낀 점</strong>\n클로져는 재미있는 개념이다. 클로져란 개념을 이해하기 위해서 11개 정도의 글을 정독하였는데, 사람마다 이해하는 클로져의 개념이 다 똑같은것 같지는 않다.\n최대한 다양한 관점에서 클로져를 바라보고 글을 쓸려고 노력하였는데 결국 나랑 비슷한 사람의 글을 거의 베끼다시피 한것 같다.\n언제나 느끼지만 글쓰기는 참 어렵다.</p>\n<p><strong>참고</strong></p>\n<ol>\n<li>http://blog.javarouka.me/2012/01/javascripts-closure.html</li>\n<li>http://meetup.toast.com/posts/86</li>\n<li>http://unikys.tistory.com/309</li>\n</ol>\n","summary":"<p>자바스크립트의 주요 개념중 하나인 클로져에 대해 자세히 알아보자.</p>\n","slug":"2017-10-03-js-closure","link":"/blog/2017-10-03-js-closure"}}]]}]
